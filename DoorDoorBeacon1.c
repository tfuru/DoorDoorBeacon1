/** @file
 *
 * This file has been automatically generated by the WICED Smart Designer. 
 * Device configuration and functions required for the BLE device.
 *
 */

#include "bleprofile.h"
#include "bleapp.h"
#include "gpiodriver.h"
#include "string.h"
#include "stdio.h"
#include "platform.h"
#include "gpiodriver.h"

#include "doordoorbeacon1_db.h"

//GOIPに変化があった場合コールされる
void doordoorbeacon1_gpio_interrupt_handler(void* unsued, UINT8 gpio);

/******************************************************
 *                     Constants
 ******************************************************/

#define DOORDOORBEACON1_FINE_TIMER           0
#define DOORDOORBEACON1_DEVICE_NAME          "DoorDoorBeacon1"
#define DOORDOORBEACON1_DEVICE_APPEARENCE    0
#define DOORDOORBEACON1_MAIN_SERVICE_UUID    0
#define DOORDOORBEACON1_MAIN_CHAR_UUID       0
#define DOORDOORBEACON1_MAIN_CHAR_HANDLE     0

/******************************************************
 *                     Structures
 ******************************************************/

#pragma pack(1)
//host information for NVRAM
typedef PACKED struct
{
    //part of HOSTINFO generated by wizard
    __HOSTINFO generated;
    // ToDo: add your variables here which need to be saved in the NVRAM
}  HOSTINFO;
#pragma pack()

/******************************************************
 *               Function Prototypes
 ******************************************************/

static void doordoorbeacon1_create(void);
static void doordoorbeacon1_connection_up( void );
static void doordoorbeacon1_connection_down( void );
static void doordoorbeacon1_advertisement_stopped( void );
static void doordoorbeacon1_smp_bond_result( LESMP_PARING_RESULT result );
static void doordoorbeacon1_encryption_changed( HCI_EVT_HDR *evt );
static int  doordoorbeacon1_write_handler( LEGATTDB_ENTRY_HDR *p );
static void doordoorbeacon1_interrupt_handler( UINT8 value );

/******************************************************
 *               Variables Definitions
 ******************************************************/

const BLE_PROFILE_CFG doordoorbeacon1_cfg =
{
    /*.fine_timer_interval            =*/ DOORDOORBEACON1_FINE_TIMER, // ms
    /*.default_adv                    =*/ 4,    // HIGH_UNDIRECTED_DISCOVERABLE
    /*.button_adv_toggle              =*/ 0,    // pairing button make adv toggle (if 1) or always on (if 0)
    /*.high_undirect_adv_interval     =*/ 32,   // slots
    /*.low_undirect_adv_interval      =*/ 1024, // slots
    /*.high_undirect_adv_duration     =*/ 30,   // seconds
    /*.low_undirect_adv_duration      =*/ 300,  // seconds
    /*.high_direct_adv_interval       =*/ 0,    // seconds
    /*.low_direct_adv_interval        =*/ 0,    // seconds
    /*.high_direct_adv_duration       =*/ 0,    // seconds
    /*.low_direct_adv_duration        =*/ 0,    // seconds
    /*.local_name                     =*/ DOORDOORBEACON1_DEVICE_NAME, // [LOCAL_NAME_LEN_MAX];
    /*.cod                            =*/ BIT16_TO_8(DOORDOORBEACON1_DEVICE_APPEARENCE),0x00, // [COD_LEN];
    /*.ver                            =*/ "1.00",         // [VERSION_LEN];
    /*.encr_required                  =*/ 0,    //(SECURITY_ENABLED | SECURITY_REQUEST),    // data encrypted and device sends security request on every connection
    /*.disc_required                  =*/ 0,    // if 1, disconnection after confirmation
    /*.test_enable                    =*/ 1,    // TEST MODE is enabled when 1
    /*.tx_power_level                 =*/ 0x04, // dbm
    /*.con_idle_timeout               =*/ 30,   // second  0-> no timeout
    /*.powersave_timeout              =*/ 0,    // second  0-> no timeout
    /*.hdl                            =*/ {DOORDOORBEACON1_MAIN_CHAR_HANDLE, 0x00, 0x00, 0x00, 0x00}, // [HANDLE_NUM_MAX];
    /*.serv                           =*/ {DOORDOORBEACON1_MAIN_SERVICE_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.cha                            =*/ {DOORDOORBEACON1_MAIN_CHAR_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.findme_locator_enable          =*/ 0,    // if 1 Find me locator is enable
    /*.findme_alert_level             =*/ 0,    // alert level of find me
    /*.client_grouptype_enable        =*/ 0,    // if 1 grouptype read can be used
    /*.linkloss_button_enable         =*/ 0,    // if 1 linkloss button is enable
    /*.pathloss_check_interval        =*/ 0,    // second
    /*.alert_interval                 =*/ 0,    // interval of alert
    /*.high_alert_num                 =*/ 0,    // number of alert for each interval
    /*.mild_alert_num                 =*/ 0,    // number of alert for each interval
    /*.status_led_enable              =*/ 1,    // if 1 status LED is enable
    /*.status_led_interval            =*/ 0,    // second
    /*.status_led_con_blink           =*/ 0,    // blink num of connection
    /*.status_led_dir_adv_blink       =*/ 0,    // blink num of dir adv
    /*.status_led_un_adv_blink        =*/ 0,    // blink num of undir adv
    /*.led_on_ms                      =*/ 0,    // led blink on duration in ms
    /*.led_off_ms                     =*/ 0,    // led blink off duration in ms
    /*.buz_on_ms                      =*/ 100,  // buzzer on duration in ms
    /*.button_power_timeout           =*/ 0,    // seconds
    /*.button_client_timeout          =*/ 0,    // seconds
    /*.button_discover_timeout        =*/ 0,    // seconds
    /*.button_filter_timeout          =*/ 0,    // seconds
#ifdef BLE_UART_LOOPBACK_TRACE
    /*.button_uart_timeout            =*/ 15,   // seconds
#endif
};

// Following structure defines UART configuration
const BLE_PROFILE_PUART_CFG doordoorbeacon1_puart_cfg =
{
    /*.baudrate   =*/ 115200,
#ifdef GATT_DB_ENABLE_UART
    /*.txpin      =*/ GPIO_PIN_UART_TX,
    /*.rxpin      =*/ GPIO_PIN_UART_RX,
#else
    /*.txpin      =*/ PUARTDISABLE | GPIO_PIN_UART_TX,
    /*.rxpin      =*/ PUARTDISABLE | GPIO_PIN_UART_RX,
#endif
};

// NVRAM save area
HOSTINFO doordoorbeacon1_hostinfo;
//pointer to the generated part of hostinfo assuming it is the beginning of the hostinfo
__HOSTINFO *p_hostinfo_generated = &doordoorbeacon1_hostinfo.generated;

UINT16 	doordoorbeacon1_connection_handle      = 0;                  // HCI handle of connection, not zero when connected
BD_ADDR doordoorbeacon1_remote_addr            = {0, 0, 0, 0, 0, 0}; // Address of currently connected client

// ToDo: Add your static variables here

/******************************************************
 *               Function Definitions
 ******************************************************/

// Application initialization
APPLICATION_INIT()
{
    bleapp_set_cfg((UINT8 *)gatt_database,
                   gatt_database_len,
                   (void *)&doordoorbeacon1_cfg,
                   (void *)&doordoorbeacon1_puart_cfg,
                   (void *)&doordoorbeacon1_gpio_cfg,
                   doordoorbeacon1_create);
}

// Create device
void doordoorbeacon1_create(void)
{
	extern UINT8 bleprofile_adv_num;
	extern UINT8 bleprofile_scanrsp_num;

    ble_trace0("create()");
    ble_trace0(bleprofile_p_cfg->ver);

	bleprofile_adv_num = 0x0;
	bleprofile_scanrsp_num = 0x0;

    // dump the database to debug uart.
    legattdb_dumpDb();

    bleprofile_Init(bleprofile_p_cfg);
    bleprofile_GPIOInit(bleprofile_gpio_p_cfg);

    // Initialized ROM code which will monitor the battery
    blebat_Init();

    // Read NVRAM
    bleprofile_ReadNVRAM(VS_BLE_HOST_LIST, sizeof(doordoorbeacon1_hostinfo), (UINT8 *)&doordoorbeacon1_hostinfo);

    // register connection up and connection down handler.
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_UP, doordoorbeacon1_connection_up);
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_DOWN, doordoorbeacon1_connection_down);
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_ADV_TIMEOUT, doordoorbeacon1_advertisement_stopped);

    // handler for Encryption changed.
    blecm_regEncryptionChangedHandler(doordoorbeacon1_encryption_changed);

    // handler for Bond result
    lesmp_regSMPResultCb((LESMP_SINGLE_PARAM_CB) doordoorbeacon1_smp_bond_result);

    // register to process client writes
    legattdb_regWriteHandleCb((LEGATTDB_WRITE_CB)doordoorbeacon1_write_handler);

    // register interrupt handler
    bleprofile_regIntCb((BLEPROFILE_SINGLE_PARAM_CB) doordoorbeacon1_interrupt_handler);

    //registers timer
    doordoorbeacon1_reg_timer();

    // advertise first vendor specific service
    if(sizeof(doordoorbeacon1_uuid_main_vsc_service) == 16)
    {
    	// total length should be less than 31 bytes
    	BLE_ADV_FIELD adv[3];
        BLE_ADV_FIELD scr[1];

		// flags
		adv[0].len     = 1 + 1;
		adv[0].val     = ADV_FLAGS;
		adv[0].data[0] = LE_LIMITED_DISCOVERABLE | BR_EDR_NOT_SUPPORTED;

		adv[1].len     = 16 + 1;
		adv[1].val     = ADV_SERVICE_UUID128_COMP;
		memcpy(adv[1].data, &doordoorbeacon1_uuid_main_vsc_service[0], 16);

        // Tx power level
        adv[2].len     = TX_POWER_LEN+1;
        adv[2].val     = ADV_TX_POWER_LEVEL;
        adv[2].data[0] = bleprofile_p_cfg->tx_power_level;

		// name
        scr[0].len      = strlen(bleprofile_p_cfg->local_name) + 1;
        scr[0].val      = ADV_LOCAL_NAME_COMP;
        memcpy(scr[0].data, bleprofile_p_cfg->local_name, scr[0].len - 1);

		bleprofile_GenerateADVData(adv, 3);
        bleprofile_GenerateScanRspData(scr, 1);
    }

    //Tx Power Level
    blecm_setTxPowerInADV(4);

    //Low-power oscillator (低消費電力 発信器)
    bleapputils_changeLPOSource(LPO_MIA_LPO, FALSE, 500);

    // start device advertisements.  By default Advertisements will contain flags, device name,
    // appearance and main service UUID.
    bleprofile_Discoverable(HIGH_UNDIRECTED_DISCOVERABLE, NULL);

    //トグルスイッチの初期化 押されたら動作
    UINT16 interrupt_handler_mask[3] = {0, 0, 0};
    interrupt_handler_mask[BUTTON_INTERRUPT_PORT] |= (1 << BUTTON_INTERRUPT_PIN);
    // Now register the interrupt handler.
    gpio_registerForInterrupt(interrupt_handler_mask, doordoorbeacon1_gpio_interrupt_handler, NULL);
    // Now configure the pin. We will use both edges so that we know when the upper and lower thresholds are crossed.
    gpio_configurePin(BUTTON_INTERRUPT_PORT, BUTTON_INTERRUPT_PIN, GPIO_EN_INT_BOTH_EDGE | GPIO_PULL_UP, GPIO_PIN_OUTPUT_LOW);

}

// Connection up callback function is called on every connection establishment
void doordoorbeacon1_connection_up(void)
{
	doordoorbeacon1_connection_handle = (UINT16)emconinfo_getConnHandle();
	UINT8 *bda = (UINT8 *)emconninfo_getPeerPubAddr();

    // Save address of the connected device and print it out.
    memcpy(doordoorbeacon1_remote_addr, bda, sizeof(doordoorbeacon1_remote_addr));

    ble_trace3("connection_up: %08x%04x h=%d",
                (doordoorbeacon1_remote_addr[5] << 24) + (doordoorbeacon1_remote_addr[4] << 16) +
                (doordoorbeacon1_remote_addr[3] << 8) + doordoorbeacon1_remote_addr[2],
                (doordoorbeacon1_remote_addr[1] << 8) + doordoorbeacon1_remote_addr[0],
                doordoorbeacon1_connection_handle);


    // Prepare generated code for connection - write persistent values from __HOSTINFO to GATT DB
    __on_connection_up();

	// ToDo: Write custom persistent values into GATT database using functions
	// changed_<service_name>_<char_name>() generated by smart disigner

    // If device supports a single connection, stop advertising
    bleprofile_Discoverable(NO_DISCOVERABLE, NULL);

    // If security is required for every connection following function will start bonding or
    // will setup encryption.  No indications or notifications should be sent until
    // encryption is not done.
    if (bleprofile_p_cfg->encr_required & SECURITY_REQUEST)
    {
        if (emconninfo_deviceBonded())
        {
            ble_trace0("device bonded");
        }
        else
        {
            ble_trace0("device not bonded");
            lesmp_sendSecurityRequest();
        }
    }
}

// Connection down callback
void doordoorbeacon1_connection_down(void)
{
    ble_trace1("connection_down:handle:%d", doordoorbeacon1_connection_handle);

    doordoorbeacon1_connection_handle = 0;

    // If disconnection was caused by the peer, start low advertisements
    bleprofile_Discoverable(LOW_UNDIRECTED_DISCOVERABLE, NULL);

    ble_trace2("ADV start: %08x%04x",
                  (doordoorbeacon1_remote_addr[5] << 24 ) + (doordoorbeacon1_remote_addr[4] <<16) +
                  (doordoorbeacon1_remote_addr[3] << 8 ) + doordoorbeacon1_remote_addr[2],
                  (doordoorbeacon1_remote_addr[1] << 8 ) + doordoorbeacon1_remote_addr[0]);
}

// Callback function indicates to the application that advertising has stopped.
// restart advertisement if needed
void doordoorbeacon1_advertisement_stopped(void)
{
    ble_trace0("ADV stop!!!!");

	// If disconnection was caused by the peer, start low advertisements
    bleprofile_Discoverable(LOW_UNDIRECTED_DISCOVERABLE, NULL);
}

// Process SMP bonding result.  If pairing is successful with the central device,
// save its BDADDR in the NVRAM and initialize associated data
void doordoorbeacon1_smp_bond_result(LESMP_PARING_RESULT  result)
{
    ble_trace1("smp_bond_result %02x", result);

    if (result == LESMP_PAIRING_RESULT_BONDED)
    {
        // saving bd_addr in nvram
        UINT8 *bda;
        UINT8 writtenbyte;

        bda = (UINT8 *)emconninfo_getPeerPubAddr();

        // initialize persistent values in the hostinfo to add bonded peer
        doordoorbeacon1_add_bond(bda);

        // ToDo: initialize persistent variables in HOSTINFO

        //now write hostinfo into NVRAM
        writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(doordoorbeacon1_hostinfo), (UINT8 *)&doordoorbeacon1_hostinfo);
        ble_trace1("NVRAM write:%04x", writtenbyte);
    }
}

// Notification from the stack that encryption has been set.
void doordoorbeacon1_encryption_changed(HCI_EVT_HDR *evt)
{
    UINT8 *bda = emconninfo_getPeerPubAddr();

    ble_trace2("encryption changed %08x%04x",
                (bda[5] << 24) + (bda[4] << 16) +
                (bda[3] << 8) + bda[2],
                (bda[1] << 8) + bda[0]);

    // ToDo: do your on-encryption-change actions here.

    // Slow down the pace of master polls to save power.  Following request asks
    // host to setup polling every 100-500 msec, with link supervision timeout 5 seconds.
    bleprofile_SendConnParamUpdateReq(80, 400, 0, 500);
}

// Process write request or command from peer device
int doordoorbeacon1_write_handler(LEGATTDB_ENTRY_HDR *p)
{
    UINT8  writtenbyte;
    UINT16 handle   = legattdb_getHandle(p);
    int    len      = legattdb_getAttrValueLen(p);
    UINT8  *attrPtr = legattdb_getAttrValue(p);
    BOOL changed;

    ble_trace1("write_handler: handle %04x", handle);

    changed = __write_handler(handle, len, attrPtr);

    // iOSからの書き込み
    if ((len == 1) && (handle == HDLC_DOORDOOR_BLINK_VALUE)) {
    	doordoorbeacon1_hostinfo.generated.doordoor_blink_client_configuration = attrPtr[0];
    	if (doordoorbeacon1_hostinfo.generated.doordoor_blink_client_configuration != 0)
    	{
    		bleprofile_LEDBlink(250, 250, doordoorbeacon1_hostinfo.generated.doordoor_blink_client_configuration);
    	}
    }

    // Save update to NVRAM if it has been changed.
    if (changed)
    {
		writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(doordoorbeacon1_hostinfo), (UINT8 *)&doordoorbeacon1_hostinfo);
		ble_trace1("NVRAM write:%04x", writtenbyte);
    }
    return 0;
}

// Three Interrupt inputs (Buttons) can be handled here.
// If the following value == 1, Button is pressed. Different than initial value.
// If the following value == 0, Button is depressed. Same as initial value.
// Button1 : value&0x01
// Button2 : (value&0x02)>>1
// Button3 : (value&0x04)>>2
void doordoorbeacon1_interrupt_handler(UINT8 value)
{
    // ToDo: handle the interrupts here.
    ble_trace1("interrupt_handler:handle:%d", value);
}

// Process indication confirmation.  if client service indication, each indication
// should be acknowledged before the next one can be sent.
void doordoorbeacon1_indication_cfm(void)
{
}

//------ generated code

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_doordoor1_blink(int len, UINT8 *attrPtr)
{
    //Todo: do you actions here when value is written by the peer
    // and return TRUE if any persistent value is changed
    return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_doordoor_blink(int len, UINT8 *attrPtr)
{
    //Todo: do you actions here when value is written by the peer
    // and return TRUE if any persistent value is changed
    return FALSE;
}

//スイッチ トグル用フラグ
static BOOL SWITCH_TOGGLE = FALSE;

//GOIPに変化があった場合コールされる
void doordoorbeacon1_gpio_interrupt_handler(void* unsued, UINT8 gpio){
	//ble_trace2("gpio_interrupt_handler PIN:%d SWITCH_TOGGLE:%d\n",gpio,SWITCH_TOGGLE);
	switch(gpio)
	{
	case BUTTON_INTERRUPT_PIN:
		//ボタンが押される度に点灯,消灯を1回だけ実行
		bleprofile_LEDBlink(250, 250, (UINT16) 01);
		//ボタンの状態を取得
		BYTE button_level = gpio_getPinInput(BUTTON_INTERRUPT_PORT, BUTTON_INTERRUPT_PIN);
		BYTE val = (button_level==0)?1:0;
		//値を保存
		store_in_db_doordoor_button(&val,1,TRUE,TRUE);
		//通知は必要なさそう
		//bleprofile_sendNotification(HDLC_DOORDOOR_BUTTON_VALUE, &button_level, 1);
		if(SWITCH_TOGGLE == FALSE){
			SWITCH_TOGGLE = TRUE;
		}
		else{
			//ボタンを離した場合 0
			SWITCH_TOGGLE = FALSE;
		}
		break;
	default:
		break;
	}
}

